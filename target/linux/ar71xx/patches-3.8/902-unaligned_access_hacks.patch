--- a/arch/mips/include/asm/checksum.h
+++ b/arch/mips/include/asm/checksum.h
@@ -104,26 +104,30 @@ static inline __sum16 ip_fast_csum(const
 	const unsigned int *stop = word + ihl;
 	unsigned int csum;
 	int carry;
+	unsigned int w;
 
-	csum = word[0];
-	csum += word[1];
-	carry = (csum < word[1]);
+	csum = net_hdr_word(word++);
+
+	w = net_hdr_word(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[2];
-	carry = (csum < word[2]);
+	w = net_hdr_word(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	csum += word[3];
-	carry = (csum < word[3]);
+	w = net_hdr_word(word++);
+	csum += w;
+	carry = (csum < w);
 	csum += carry;
 
-	word += 4;
 	do {
-		csum += *word;
-		carry = (csum < *word);
+		w = net_hdr_word(word++);
+		csum += w;
+		carry = (csum < w);
 		csum += carry;
-		word++;
 	} while (word != stop);
 
 	return csum_fold(csum);
@@ -192,69 +196,4 @@ static inline __sum16 ip_compute_csum(co
 	return csum_fold(csum_partial(buff, len, 0));
 }
 
-#define _HAVE_ARCH_IPV6_CSUM
-static __inline__ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
-				          const struct in6_addr *daddr,
-					  __u32 len, unsigned short proto,
-					  __wsum sum)
-{
-	__asm__(
-	"	.set	push		# csum_ipv6_magic\n"
-	"	.set	noreorder	\n"
-	"	.set	noat		\n"
-	"	addu	%0, %5		# proto (long in network byte order)\n"
-	"	sltu	$1, %0, %5	\n"
-	"	addu	%0, $1		\n"
-
-	"	addu	%0, %6		# csum\n"
-	"	sltu	$1, %0, %6	\n"
-	"	lw	%1, 0(%2)	# four words source address\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 4(%2)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 8(%2)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 12(%2)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 0(%3)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 4(%3)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 8(%3)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	lw	%1, 12(%3)	\n"
-	"	addu	%0, $1		\n"
-	"	addu	%0, %1		\n"
-	"	sltu	$1, %0, %1	\n"
-
-	"	addu	%0, $1		# Add final carry\n"
-	"	.set	pop"
-	: "=r" (sum), "=r" (proto)
-	: "r" (saddr), "r" (daddr),
-	  "0" (htonl(len)), "1" (htonl(proto)), "r" (sum));
-
-	return csum_fold(sum);
-}
-
 #endif /* _ASM_CHECKSUM_H */
--- a/include/uapi/linux/ip.h
+++ b/include/uapi/linux/ip.h
@@ -102,7 +102,7 @@ struct iphdr {
 	__be32	saddr;
 	__be32	daddr;
 	/*The options start here. */
-};
+} __attribute__((packed, aligned(2)));
 
 
 struct ip_auth_hdr {
--- a/include/uapi/linux/ipv6.h
+++ b/include/uapi/linux/ipv6.h
@@ -123,7 +123,7 @@ struct ipv6hdr {
 
 	struct	in6_addr	saddr;
 	struct	in6_addr	daddr;
-};
+} __attribute__((packed, aligned(2)));
 
 
 /* index values for the variables in ipv6_devconf */
--- a/include/uapi/linux/tcp.h
+++ b/include/uapi/linux/tcp.h
@@ -54,7 +54,7 @@ struct tcphdr {
 	__be16	window;
 	__sum16	check;
 	__be16	urg_ptr;
-};
+} __attribute__((packed, aligned(2)));
 
 /*
  *	The union cast uses a gcc extension to avoid aliasing problems
@@ -64,7 +64,7 @@ struct tcphdr {
 union tcp_word_hdr { 
 	struct tcphdr hdr;
 	__be32 		  words[5];
-}; 
+} __attribute__((packed, aligned(2)));
 
 #define tcp_flag_word(tp) ( ((union tcp_word_hdr *)(tp))->words [3]) 
 
--- a/include/uapi/linux/udp.h
+++ b/include/uapi/linux/udp.h
@@ -24,7 +24,7 @@ struct udphdr {
 	__be16	dest;
 	__be16	len;
 	__sum16	check;
-};
+} __attribute__((packed, aligned(2)));
 
 /* UDP socket options */
 #define UDP_CORK	1	/* Never send partially complete segments */
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@ -39,8 +39,8 @@ static bool ipv4_pkt_to_tuple(const stru
 	if (ap == NULL)
 		return false;
 
-	tuple->src.u3.ip = ap[0];
-	tuple->dst.u3.ip = ap[1];
+	tuple->src.u3.ip = net_hdr_word(ap++);
+	tuple->dst.u3.ip = net_hdr_word(ap);
 
 	return true;
 }
--- a/include/uapi/linux/icmp.h
+++ b/include/uapi/linux/icmp.h
@@ -80,7 +80,7 @@ struct icmphdr {
 		__be16	mtu;
 	} frag;
   } un;
-};
+} __attribute__((packed, aligned(2)));
 
 
 /*
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -3896,13 +3896,14 @@ static bool tcp_parse_aligned_timestamp(
 {
 	const __be32 *ptr = (const __be32 *)(th + 1);
 
-	if (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)
-			  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {
+	if (net_hdr_word(ptr) ==
+	    htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
+	    (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {
 		tp->rx_opt.saw_tstamp = 1;
 		++ptr;
-		tp->rx_opt.rcv_tsval = ntohl(*ptr);
+		tp->rx_opt.rcv_tsval = get_unaligned_be32(ptr);
 		++ptr;
-		tp->rx_opt.rcv_tsecr = ntohl(*ptr);
+		tp->rx_opt.rcv_tsecr = get_unaligned_be32(ptr);
 		return true;
 	}
 	return false;
--- a/include/uapi/linux/in6.h
+++ b/include/uapi/linux/in6.h
@@ -36,7 +36,7 @@ struct in6_addr {
 #define s6_addr			in6_u.u6_addr8
 #define s6_addr16		in6_u.u6_addr16
 #define s6_addr32		in6_u.u6_addr32
-};
+} __attribute__((packed, aligned(2)));
 
 /* IPv6 Wildcard Address (::) and Loopback Address (::1) defined in RFC2553
  * NOTE: Be aware the IN6ADDR_* constants and in6addr_* externals are defined
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -61,6 +61,7 @@
 #endif
 
 #include <asm/uaccess.h>
+#include <asm/unaligned.h>
 #include <linux/mroute6.h>
 
 MODULE_AUTHOR("Cast of dozens");
@@ -688,7 +689,7 @@ bool ipv6_opt_accepted(const struct sock
 		if ((opt->hop && (np->rxopt.bits.hopopts ||
 				  np->rxopt.bits.ohopopts)) ||
 		    ((IPV6_FLOWINFO_MASK &
-		      *(__be32 *)skb_network_header(skb)) &&
+		      net_hdr_word(skb_network_header(skb))) &&
 		     np->rxopt.bits.rxflow) ||
 		    (opt->srcrt && (np->rxopt.bits.srcrt ||
 		     np->rxopt.bits.osrcrt)) ||
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -995,7 +995,7 @@ void ip6_route_input(struct sk_buff *skb
 		.flowi6_iif = skb->dev->ifindex,
 		.daddr = iph->daddr,
 		.saddr = iph->saddr,
-		.flowlabel = (* (__be32 *) iph) & IPV6_FLOWINFO_MASK,
+		.flowlabel = net_hdr_word(iph) & IPV6_FLOWINFO_MASK,
 		.flowi6_mark = skb->mark,
 		.flowi6_proto = iph->nexthdr,
 	};
@@ -1159,7 +1159,7 @@ void ip6_update_pmtu(struct sk_buff *skb
 	fl6.flowi6_flags = 0;
 	fl6.daddr = iph->daddr;
 	fl6.saddr = iph->saddr;
-	fl6.flowlabel = (*(__be32 *) iph) & IPV6_FLOWINFO_MASK;
+	fl6.flowlabel = net_hdr_word(iph) & IPV6_FLOWINFO_MASK,
 
 	dst = ip6_route_output(net, NULL, &fl6);
 	if (!dst->error)
@@ -1187,7 +1187,7 @@ void ip6_redirect(struct sk_buff *skb, s
 	fl6.flowi6_flags = 0;
 	fl6.daddr = iph->daddr;
 	fl6.saddr = iph->saddr;
-	fl6.flowlabel = (*(__be32 *) iph) & IPV6_FLOWINFO_MASK;
+	fl6.flowlabel = net_hdr_word(iph) & IPV6_FLOWINFO_MASK,
 
 	dst = ip6_route_output(net, NULL, &fl6);
 	if (!dst->error)
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -64,6 +64,7 @@
 #include <net/secure_seq.h>
 #include <net/tcp_memcontrol.h>
 
+#include <asm/unaligned.h>
 #include <asm/uaccess.h>
 
 #include <linux/proc_fs.h>
@@ -764,10 +765,10 @@ static void tcp_v6_send_response(struct
 	topt = (__be32 *)(t1 + 1);
 
 	if (ts) {
-		*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |
-				(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);
-		*topt++ = htonl(tcp_time_stamp);
-		*topt++ = htonl(ts);
+		put_unaligned_be32((TCPOPT_NOP << 24) |	(TCPOPT_NOP << 16) |
+			(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP, topt++);
+		put_unaligned_be32(tcp_time_stamp, topt++);
+		put_unaligned_be32(ts, topt++);
 	}
 
 #ifdef CONFIG_TCP_MD5SIG
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@ -4,6 +4,7 @@
 #include <uapi/linux/ipv6.h>
 
 #define ipv6_optlen(p)  (((p)->hdrlen+1) << 3)
+
 /*
  * This structure contains configuration options per IPv6 link.
  */
@@ -79,7 +80,7 @@ static inline struct ipv6hdr *ipipv6_hdr
 
 static inline __u8 ipv6_tclass(const struct ipv6hdr *iph)
 {
-	return (ntohl(*(__be32 *)iph) >> 20) & 0xff;
+	return (ntohl(net_hdr_word(iph)) >> 20) & 0xff;
 }
 
 /* 
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -360,12 +360,12 @@ int ipv6_recv_error(struct sock *sk, str
 				*(struct in6_addr *)(nh + serr->addr_offset);
 			if (np->sndflow)
 				sin->sin6_flowinfo =
-					(*(__be32 *)(nh + serr->addr_offset - 24) &
-					 IPV6_FLOWINFO_MASK);
+					net_hdr_word(nh + serr->addr_offset - 24) &
+					 IPV6_FLOWINFO_MASK;
 			if (ipv6_addr_type(&sin->sin6_addr) & IPV6_ADDR_LINKLOCAL)
 				sin->sin6_scope_id = IP6CB(skb)->iif;
 		} else {
-			ipv6_addr_set_v4mapped(*(__be32 *)(nh + serr->addr_offset),
+			ipv6_addr_set_v4mapped(net_hdr_word(nh + serr->addr_offset),
 					       &sin->sin6_addr);
 		}
 	}
@@ -493,9 +493,10 @@ int ip6_datagram_recv_ctl(struct sock *s
 		put_cmsg(msg, SOL_IPV6, IPV6_TCLASS, sizeof(tclass), &tclass);
 	}
 
-	if (np->rxopt.bits.rxflow && (*(__be32 *)nh & IPV6_FLOWINFO_MASK)) {
-		__be32 flowinfo = *(__be32 *)nh & IPV6_FLOWINFO_MASK;
-		put_cmsg(msg, SOL_IPV6, IPV6_FLOWINFO, sizeof(flowinfo), &flowinfo);
+	if (np->rxopt.bits.rxflow) {
+		__be32 flowinfo = net_hdr_word(nh) & IPV6_FLOWINFO_MASK;
+		if (flowinfo)
+			put_cmsg(msg, SOL_IPV6, IPV6_FLOWINFO, sizeof(flowinfo), &flowinfo);
 	}
 
 	/* HbH is allowed only once */
@@ -682,12 +683,12 @@ int ip6_datagram_send_ctl(struct net *ne
 			}
 
 			if (fl6->flowlabel&IPV6_FLOWINFO_MASK) {
-				if ((fl6->flowlabel^*(__be32 *)CMSG_DATA(cmsg))&~IPV6_FLOWINFO_MASK) {
+				if ((fl6->flowlabel^net_hdr_word(CMSG_DATA(cmsg)))&~IPV6_FLOWINFO_MASK) {
 					err = -EINVAL;
 					goto exit_f;
 				}
 			}
-			fl6->flowlabel = IPV6_FLOWINFO_MASK & *(__be32 *)CMSG_DATA(cmsg);
+			fl6->flowlabel = IPV6_FLOWINFO_MASK & net_hdr_word(CMSG_DATA(cmsg));
 			break;
 
 		case IPV6_2292HOPOPTS:
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@ -430,7 +430,7 @@ static void ip6gre_err(struct sk_buff *s
 
 	t = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,
 				flags & GRE_KEY ?
-				*(((__be32 *)p) + (grehlen / 4) - 1) : 0,
+				net_hdr_word(((__be32 *)p) + (grehlen / 4) - 1) : 0,
 				p[1]);
 	if (t == NULL)
 		return;
@@ -522,11 +522,11 @@ static int ip6gre_rcv(struct sk_buff *sk
 			offset += 4;
 		}
 		if (flags&GRE_KEY) {
-			key = *(__be32 *)(h + offset);
+			key = net_hdr_word(h + offset);
 			offset += 4;
 		}
 		if (flags&GRE_SEQ) {
-			seqno = ntohl(*(__be32 *)(h + offset));
+			seqno = ntohl(net_hdr_word(h + offset));
 			offset += 4;
 		}
 	}
@@ -772,7 +772,7 @@ static netdev_tx_t ip6gre_xmit2(struct s
 	 *	Push down and install the IP header.
 	 */
 	ipv6h = ipv6_hdr(skb);
-	*(__be32 *)ipv6h = fl6->flowlabel | htonl(0x60000000);
+	net_hdr_word(ipv6h) = fl6->flowlabel | htonl(0x60000000);
 	dsfield = INET_ECN_encapsulate(0, dsfield);
 	ipv6_change_dsfield(ipv6h, ~INET_ECN_MASK, dsfield);
 	ipv6h->hop_limit = tunnel->parms.hop_limit;
@@ -789,7 +789,7 @@ static netdev_tx_t ip6gre_xmit2(struct s
 
 		if (tunnel->parms.o_flags&GRE_SEQ) {
 			++tunnel->o_seqno;
-			*ptr = htonl(tunnel->o_seqno);
+			net_hdr_word(ptr) = htonl(tunnel->o_seqno);
 			ptr--;
 		}
 		if (tunnel->parms.o_flags&GRE_KEY) {
@@ -897,9 +897,9 @@ static inline int ip6gre_xmit_ipv6(struc
 
 	dsfield = ipv6_get_dsfield(ipv6h);
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
-		fl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_TCLASS_MASK);
+		fl6.flowlabel |= net_hdr_word(ipv6h) & IPV6_TCLASS_MASK;
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)
-		fl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_FLOWLABEL_MASK);
+		fl6.flowlabel |= net_hdr_word(ipv6h) & IPV6_FLOWLABEL_MASK;
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
 		fl6.flowi6_mark = skb->mark;
 
@@ -1240,7 +1240,7 @@ static int ip6gre_header(struct sk_buff
 	struct ipv6hdr *ipv6h = (struct ipv6hdr *)skb_push(skb, t->hlen);
 	__be16 *p = (__be16 *)(ipv6h+1);
 
-	*(__be32 *)ipv6h = t->fl.u.ip6.flowlabel | htonl(0x60000000);
+	net_hdr_word(ipv6h) = t->fl.u.ip6.flowlabel | htonl(0x60000000);
 	ipv6h->hop_limit = t->parms.hop_limit;
 	ipv6h->nexthdr = NEXTHDR_GRE;
 	ipv6h->saddr = t->parms.laddr;
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -216,7 +216,7 @@ int ip6_xmit(struct sock *sk, struct sk_
 	if (hlimit < 0)
 		hlimit = ip6_dst_hoplimit(dst);
 
-	*(__be32 *)hdr = htonl(0x60000000 | (tclass << 20)) | fl6->flowlabel;
+	net_hdr_word(hdr) = htonl(0x60000000 | (tclass << 20)) | fl6->flowlabel;
 
 	hdr->payload_len = htons(seg_len);
 	hdr->nexthdr = proto;
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@ -1136,9 +1136,9 @@ ip6ip6_tnl_xmit(struct sk_buff *skb, str
 
 	dsfield = ipv6_get_dsfield(ipv6h);
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
-		fl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_TCLASS_MASK);
+		fl6.flowlabel |= net_hdr_word(ipv6h) & IPV6_TCLASS_MASK;
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)
-		fl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_FLOWLABEL_MASK);
+		fl6.flowlabel |= net_hdr_word(ipv6h) & IPV6_FLOWLABEL_MASK;
 	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
 		fl6.flowi6_mark = skb->mark;
 
--- a/net/ipv6/exthdrs.c
+++ b/net/ipv6/exthdrs.c
@@ -578,7 +578,7 @@ static bool ipv6_hop_jumbo(struct sk_buf
 		goto drop;
 	}
 
-	pkt_len = ntohl(*(__be32 *)(nh + optoff + 2));
+	pkt_len = ntohl(net_hdr_word(nh + optoff + 2));
 	if (pkt_len <= IPV6_MAXPLEN) {
 		IP6_INC_STATS_BH(net, ipv6_skb_idev(skb),
 				 IPSTATS_MIB_INHDRERRORS);
--- a/include/linux/types.h
+++ b/include/linux/types.h
@@ -212,5 +212,11 @@ struct callback_head {
 };
 #define rcu_head callback_head
 
+struct net_hdr_word {
+       u32 words[1];
+} __attribute__((packed, aligned(2)));
+
+#define net_hdr_word(_p) (((struct net_hdr_word *) (_p))->words[0])
+
 #endif /*  __ASSEMBLY__ */
 #endif /* _LINUX_TYPES_H */
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -1396,8 +1396,8 @@ static struct sk_buff **inet_gro_receive
 	if (unlikely(ip_fast_csum((u8 *)iph, 5)))
 		goto out_unlock;
 
-	id = ntohl(*(__be32 *)&iph->id);
-	flush = (u16)((ntohl(*(__be32 *)iph) ^ skb_gro_len(skb)) | (id ^ IP_DF));
+	id = ntohl(net_hdr_word(&iph->id));
+	flush = (u16)((ntohl(net_hdr_word(iph)) ^ skb_gro_len(skb)) | (id ^ IP_DF));
 	id >>= 16;
 
 	for (p = *head; p; p = p->next) {
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -465,7 +465,7 @@ static struct neighbour *ipv4_neigh_look
 	else if (skb)
 		pkey = &ip_hdr(skb)->daddr;
 
-	n = __ipv4_neigh_lookup(dev, *(__force u32 *)pkey);
+	n = __ipv4_neigh_lookup(dev, net_hdr_word(pkey));
 	if (n)
 		return n;
 	return neigh_create(&arp_tbl, pkey, dev);
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -456,15 +456,17 @@ static void tcp_options_write(__be32 *pt
 	 */
 	if (unlikely(OPTION_MD5 & options)) {
 		if (unlikely(OPTION_COOKIE_EXTENSION & options)) {
-			*ptr++ = htonl((TCPOPT_COOKIE << 24) |
-				       (TCPOLEN_COOKIE_BASE << 16) |
-				       (TCPOPT_MD5SIG << 8) |
-				       TCPOLEN_MD5SIG);
+			net_hdr_word(ptr++) =
+				htonl((TCPOPT_COOKIE << 24) |
+				      (TCPOLEN_COOKIE_BASE << 16) |
+				      (TCPOPT_MD5SIG << 8) |
+				      TCPOLEN_MD5SIG);
 		} else {
-			*ptr++ = htonl((TCPOPT_NOP << 24) |
-				       (TCPOPT_NOP << 16) |
-				       (TCPOPT_MD5SIG << 8) |
-				       TCPOLEN_MD5SIG);
+			net_hdr_word(ptr++) =
+				htonl((TCPOPT_NOP << 24) |
+				      (TCPOPT_NOP << 16) |
+				      (TCPOPT_MD5SIG << 8) |
+				      TCPOLEN_MD5SIG);
 		}
 		options &= ~OPTION_COOKIE_EXTENSION;
 		/* overload cookie hash location */
@@ -473,26 +475,28 @@ static void tcp_options_write(__be32 *pt
 	}
 
 	if (unlikely(opts->mss)) {
-		*ptr++ = htonl((TCPOPT_MSS << 24) |
-			       (TCPOLEN_MSS << 16) |
-			       opts->mss);
+		net_hdr_word(ptr++) =
+			htonl((TCPOPT_MSS << 24) | (TCPOLEN_MSS << 16) |
+			      opts->mss);
 	}
 
 	if (likely(OPTION_TS & options)) {
 		if (unlikely(OPTION_SACK_ADVERTISE & options)) {
-			*ptr++ = htonl((TCPOPT_SACK_PERM << 24) |
-				       (TCPOLEN_SACK_PERM << 16) |
-				       (TCPOPT_TIMESTAMP << 8) |
-				       TCPOLEN_TIMESTAMP);
+			net_hdr_word(ptr++) =
+				htonl((TCPOPT_SACK_PERM << 24) |
+				      (TCPOLEN_SACK_PERM << 16) |
+				      (TCPOPT_TIMESTAMP << 8) |
+				      TCPOLEN_TIMESTAMP);
 			options &= ~OPTION_SACK_ADVERTISE;
 		} else {
-			*ptr++ = htonl((TCPOPT_NOP << 24) |
-				       (TCPOPT_NOP << 16) |
-				       (TCPOPT_TIMESTAMP << 8) |
-				       TCPOLEN_TIMESTAMP);
+			net_hdr_word(ptr++) =
+				htonl((TCPOPT_NOP << 24) |
+				      (TCPOPT_NOP << 16) |
+				      (TCPOPT_TIMESTAMP << 8) |
+				      TCPOLEN_TIMESTAMP);
 		}
-		*ptr++ = htonl(opts->tsval);
-		*ptr++ = htonl(opts->tsecr);
+		net_hdr_word(ptr++) = htonl(opts->tsval);
+		net_hdr_word(ptr++) = htonl(opts->tsecr);
 	}
 
 	/* Specification requires after timestamp, so do it now.
@@ -512,19 +516,20 @@ static void tcp_options_write(__be32 *pt
 			__u8 *p = (__u8 *)ptr;
 
 			/* 16-bit multiple */
-			*p++ = TCPOPT_COOKIE;
-			*p++ = TCPOLEN_COOKIE_BASE + cookie_size;
-			*p++ = *cookie_copy++;
-			*p++ = *cookie_copy++;
+			net_hdr_word(p++) = TCPOPT_COOKIE;
+			net_hdr_word(p++) = TCPOLEN_COOKIE_BASE + cookie_size;
+			net_hdr_word(p++) = *cookie_copy++;
+			net_hdr_word(p++) = *cookie_copy++;
 			ptr++;
 			cookie_size -= 2;
 		} else {
 			/* 32-bit multiple */
-			*ptr++ = htonl(((TCPOPT_NOP << 24) |
-					(TCPOPT_NOP << 16) |
-					(TCPOPT_COOKIE << 8) |
-					TCPOLEN_COOKIE_BASE) +
-				       cookie_size);
+			net_hdr_word(ptr++) =
+				htonl(((TCPOPT_NOP << 24) |
+				       (TCPOPT_NOP << 16) |
+				       (TCPOPT_COOKIE << 8) |
+				       TCPOLEN_COOKIE_BASE) +
+				      cookie_size);
 		}
 
 		if (cookie_size > 0) {
@@ -534,17 +539,19 @@ static void tcp_options_write(__be32 *pt
 	}
 
 	if (unlikely(OPTION_SACK_ADVERTISE & options)) {
-		*ptr++ = htonl((TCPOPT_NOP << 24) |
-			       (TCPOPT_NOP << 16) |
-			       (TCPOPT_SACK_PERM << 8) |
-			       TCPOLEN_SACK_PERM);
+		net_hdr_word(ptr++) =
+			htonl((TCPOPT_NOP << 24) |
+			      (TCPOPT_NOP << 16) |
+			      (TCPOPT_SACK_PERM << 8) |
+			      TCPOLEN_SACK_PERM);
 	}
 
 	if (unlikely(OPTION_WSCALE & options)) {
-		*ptr++ = htonl((TCPOPT_NOP << 24) |
-			       (TCPOPT_WINDOW << 16) |
-			       (TCPOLEN_WINDOW << 8) |
-			       opts->ws);
+		net_hdr_word(ptr++) =
+			htonl((TCPOPT_NOP << 24) |
+			      (TCPOPT_WINDOW << 16) |
+			      (TCPOLEN_WINDOW << 8) |
+			      opts->ws);
 	}
 
 	if (unlikely(opts->num_sack_blocks)) {
@@ -552,16 +559,17 @@ static void tcp_options_write(__be32 *pt
 			tp->duplicate_sack : tp->selective_acks;
 		int this_sack;
 
-		*ptr++ = htonl((TCPOPT_NOP  << 24) |
-			       (TCPOPT_NOP  << 16) |
-			       (TCPOPT_SACK <<  8) |
-			       (TCPOLEN_SACK_BASE + (opts->num_sack_blocks *
+		net_hdr_word(ptr++) =
+			htonl((TCPOPT_NOP << 24) |
+			      (TCPOPT_NOP << 16) |
+			      (TCPOPT_SACK << 8) |
+			      (TCPOLEN_SACK_BASE + (opts->num_sack_blocks *
 						     TCPOLEN_SACK_PERBLOCK)));
 
 		for (this_sack = 0; this_sack < opts->num_sack_blocks;
 		     ++this_sack) {
-			*ptr++ = htonl(sp[this_sack].start_seq);
-			*ptr++ = htonl(sp[this_sack].end_seq);
+			net_hdr_word(ptr++) = htonl(sp[this_sack].start_seq);
+			net_hdr_word(ptr++) = htonl(sp[this_sack].end_seq);
 		}
 
 		tp->rx_opt.dsack = 0;
@@ -570,9 +578,10 @@ static void tcp_options_write(__be32 *pt
 	if (unlikely(OPTION_FAST_OPEN_COOKIE & options)) {
 		struct tcp_fastopen_cookie *foc = opts->fastopen_cookie;
 
-		*ptr++ = htonl((TCPOPT_EXP << 24) |
-			       ((TCPOLEN_EXP_FASTOPEN_BASE + foc->len) << 16) |
-			       TCPOPT_FASTOPEN_MAGIC);
+		net_hdr_word(ptr++) =
+			htonl((TCPOPT_EXP << 24) |
+			      ((TCPOLEN_EXP_FASTOPEN_BASE + foc->len) << 16) |
+			      TCPOPT_FASTOPEN_MAGIC);
 
 		memcpy(ptr, foc->val, foc->len);
 		if ((foc->len & 3) == 2) {
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@ -470,7 +470,7 @@ static struct sk_buff *add_grec(struct s
 		if (!skb)
 			return NULL;
 		psrc = (__be32 *)skb_put(skb, sizeof(__be32));
-		*psrc = psf->sf_inaddr;
+		net_hdr_word(psrc) = psf->sf_inaddr;
 		scount++; stotal++;
 		if ((type == IGMPV3_ALLOW_NEW_SOURCES ||
 		     type == IGMPV3_BLOCK_OLD_SOURCES) && psf->sf_crcount) {
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@ -518,7 +518,7 @@ static void ipgre_err(struct sk_buff *sk
 		return;
 
 	if (flags & GRE_KEY)
-		key = *(((__be32 *)p) + (grehlen / 4) - 1);
+		key = net_hdr_word(((__be32 *)p) + (grehlen / 4) - 1);
 
 	switch (type) {
 	default:
--- a/include/uapi/linux/igmp.h
+++ b/include/uapi/linux/igmp.h
@@ -32,7 +32,7 @@ struct igmphdr {
 	__u8 code;		/* For newer IGMP */
 	__sum16 csum;
 	__be32 group;
-};
+} __attribute__((packed, aligned(2)));
 
 /* V3 group record types [grec_type] */
 #define IGMPV3_MODE_IS_INCLUDE		1
@@ -48,7 +48,7 @@ struct igmpv3_grec {
 	__be16	grec_nsrcs;
 	__be32	grec_mca;
 	__be32	grec_src[0];
-};
+} __attribute__((packed, aligned(2)));
 
 struct igmpv3_report {
 	__u8 type;
@@ -57,7 +57,7 @@ struct igmpv3_report {
 	__be16 resv2;
 	__be16 ngrec;
 	struct igmpv3_grec grec[0];
-};
+} __attribute__((packed, aligned(2)));
 
 struct igmpv3_query {
 	__u8 type;
@@ -78,7 +78,7 @@ struct igmpv3_query {
 	__u8 qqic;
 	__be16 nsrcs;
 	__be32 srcs[0];
-};
+} __attribute__((packed, aligned(2)));
 
 #define IGMP_HOST_MEMBERSHIP_QUERY	0x11	/* From RFC1112 */
 #define IGMP_HOST_MEMBERSHIP_REPORT	0x12	/* Ditto */
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@ -137,7 +137,7 @@ ipv6:
 		nhoff += poff;
 		ports = skb_header_pointer(skb, nhoff, sizeof(_ports), &_ports);
 		if (ports)
-			flow->ports = *ports;
+			flow->ports = net_hdr_word(ports);
 	}
 
 	return true;
--- a/include/uapi/linux/icmpv6.h
+++ b/include/uapi/linux/icmpv6.h
@@ -76,7 +76,7 @@ struct icmp6hdr {
 #define icmp6_addrconf_other	icmp6_dataun.u_nd_ra.other
 #define icmp6_rt_lifetime	icmp6_dataun.u_nd_ra.rt_lifetime
 #define icmp6_router_pref	icmp6_dataun.u_nd_ra.router_pref
-};
+} __attribute__((packed, aligned(2)));
 
 
 #define ICMPV6_ROUTER_PREF_LOW		0x3
--- a/include/net/ndisc.h
+++ b/include/net/ndisc.h
@@ -76,7 +76,7 @@ struct ra_msg {
         struct icmp6hdr		icmph;
 	__be32			reachable_time;
 	__be32			retrans_timer;
-};
+} __attribute__((packed, aligned(2)));
 
 struct rd_msg {
 	struct icmp6hdr icmph;
@@ -142,10 +142,10 @@ static inline u32 ndisc_hashfn(const voi
 {
 	const u32 *p32 = pkey;
 
-	return (((p32[0] ^ hash32_ptr(dev)) * hash_rnd[0]) +
-		(p32[1] * hash_rnd[1]) +
-		(p32[2] * hash_rnd[2]) +
-		(p32[3] * hash_rnd[3]));
+	return (((net_hdr_word(&p32[0]) ^ hash32_ptr(dev)) * hash_rnd[0]) +
+		(net_hdr_word(&p32[1]) * hash_rnd[1]) +
+		(net_hdr_word(&p32[2]) * hash_rnd[2]) +
+		(net_hdr_word(&p32[3]) * hash_rnd[3]));
 }
 
 static inline struct neighbour *__ipv6_neigh_lookup(struct neigh_table *tbl, struct net_device *dev, const void *pkey)
@@ -163,8 +163,10 @@ static inline struct neighbour *__ipv6_n
 	     n = rcu_dereference_bh(n->next)) {
 		u32 *n32 = (u32 *) n->primary_key;
 		if (n->dev == dev &&
-		    ((n32[0] ^ p32[0]) | (n32[1] ^ p32[1]) |
-		     (n32[2] ^ p32[2]) | (n32[3] ^ p32[3])) == 0) {
+		    ((n32[0] ^ net_hdr_word(&p32[0])) |
+		     (n32[1] ^ net_hdr_word(&p32[1])) |
+		     (n32[2] ^ net_hdr_word(&p32[2])) |
+		     (n32[3] ^ net_hdr_word(&p32[3]))) == 0) {
 			if (!atomic_inc_not_zero(&n->refcnt))
 				n = NULL;
 			break;
--- a/net/sched/cls_u32.c
+++ b/net/sched/cls_u32.c
@@ -142,7 +142,7 @@ next_knode:
 			data = skb_header_pointer(skb, toff, 4, &hdata);
 			if (!data)
 				goto out;
-			if ((*data ^ key->val) & key->mask) {
+			if ((net_hdr_word(data) ^ key->val) & key->mask) {
 				n = n->next;
 				goto next_knode;
 			}
@@ -193,8 +193,8 @@ check_terminal:
 						  &hdata);
 			if (!data)
 				goto out;
-			sel = ht->divisor & u32_hash_fold(*data, &n->sel,
-							  n->fshift);
+			sel = ht->divisor & u32_hash_fold(net_hdr_word(data),
+							  &n->sel, n->fshift);
 		}
 		if (!(n->sel.flags & (TC_U32_VAROFFSET | TC_U32_OFFSET | TC_U32_EAT)))
 			goto next_ht;
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@ -200,7 +200,7 @@ static struct sk_buff **ipv6_gro_receive
 			continue;
 
 		iph2 = ipv6_hdr(p);
-		first_word = *(__be32 *)iph ^ *(__be32 *)iph2 ;
+		first_word = net_hdr_word(iph) ^ net_hdr_word(iph2);
 
 		/* All fields must match except length and Traffic Class. */
 		if (nlen != skb_network_header_len(p) ||
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -39,7 +39,7 @@ struct prefix_info {
 	__be32			reserved2;
 
 	struct in6_addr		prefix;
-};
+} __attribute__((packed, aligned(2)));
 
 
 #include <linux/netdevice.h>
--- a/include/net/inet_ecn.h
+++ b/include/net/inet_ecn.h
@@ -115,13 +115,13 @@ static inline int IP6_ECN_set_ce(struct
 {
 	if (INET_ECN_is_not_ect(ipv6_get_dsfield(iph)))
 		return 0;
-	*(__be32*)iph |= htonl(INET_ECN_CE << 20);
+	net_hdr_word(iph) |= htonl(INET_ECN_CE << 20);
 	return 1;
 }
 
 static inline void IP6_ECN_clear(struct ipv6hdr *iph)
 {
-	*(__be32*)iph &= ~htonl(INET_ECN_MASK << 20);
+	net_hdr_word(iph) &= ~htonl(INET_ECN_MASK << 20);
 }
 
 static inline void ipv6_copy_dscp(unsigned int dscp, struct ipv6hdr *inner)
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -107,7 +107,7 @@ struct frag_hdr {
 	__u8	reserved;
 	__be16	frag_off;
 	__be32	identification;
-};
+} __attribute__((packed, aligned(2)));
 
 #define	IP6_MF	0x0001
 
@@ -386,6 +386,8 @@ static inline bool __ipv6_prefix_equal(c
 				       unsigned int prefixlen)
 {
 	unsigned int pdw, pbi;
+	/* Used for last <32-bit fraction of prefix */
+	u32 pbia1, pbia2;
 
 	/* check complete u32 in prefix */
 	pdw = prefixlen >> 5;
@@ -394,7 +396,9 @@ static inline bool __ipv6_prefix_equal(c
 
 	/* check incomplete u32 in prefix */
 	pbi = prefixlen & 0x1f;
-	if (pbi && ((a1[pdw] ^ a2[pdw]) & htonl((0xffffffff) << (32 - pbi))))
+	pbia1 = net_hdr_word(&a1[pdw]);
+	pbia2 = net_hdr_word(&a2[pdw]);
+	if (pbi && ((pbia1 ^ pbia2) & htonl((0xffffffff) << (32 - pbi))))
 		return false;
 
 	return true;
@@ -521,13 +525,13 @@ static inline void ipv6_addr_set_v4mappe
  */
 static inline int __ipv6_addr_diff(const void *token1, const void *token2, int addrlen)
 {
-	const __be32 *a1 = token1, *a2 = token2;
+	const struct in6_addr *a1 = token1, *a2 = token2;
 	int i;
 
 	addrlen >>= 2;
 
 	for (i = 0; i < addrlen; i++) {
-		__be32 xb = a1[i] ^ a2[i];
+		__be32 xb = a1->s6_addr32[i] ^ a2->s6_addr32[i];
 		if (xb)
 			return i * 32 + 31 - __fls(ntohl(xb));
 	}
--- a/include/net/secure_seq.h
+++ b/include/net/secure_seq.h
@@ -2,6 +2,7 @@
 #define _NET_SECURE_SEQ
 
 #include <linux/types.h>
+#include <linux/in6.h>
 
 extern __u32 secure_ip_id(__be32 daddr);
 extern __u32 secure_ipv6_id(const __be32 daddr[4]);
--- a/include/uapi/linux/in.h
+++ b/include/uapi/linux/in.h
@@ -55,7 +55,7 @@ enum {
 /* Internet address. */
 struct in_addr {
 	__be32	s_addr;
-};
+} __attribute__((packed, aligned(2)));
 
 #define IP_TOS		1
 #define IP_TTL		2
--- a/net/core/secure_seq.c
+++ b/net/core/secure_seq.c
@@ -43,10 +43,11 @@ __u32 secure_tcpv6_sequence_number(const
 	u32 secret[MD5_MESSAGE_BYTES / 4];
 	u32 hash[MD5_DIGEST_WORDS];
 	u32 i;
+	const struct in6_addr *daddr6 = (struct in6_addr *) daddr;
 
 	memcpy(hash, saddr, 16);
 	for (i = 0; i < 4; i++)
-		secret[i] = net_secret[i] + (__force u32)daddr[i];
+		secret[i] = net_secret[i] + (__force u32)daddr6->s6_addr32[i];
 	secret[4] = net_secret[4] +
 		(((__force u16)sport << 16) + (__force u16)dport);
 	for (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)
@@ -64,10 +65,11 @@ u32 secure_ipv6_port_ephemeral(const __b
 	u32 secret[MD5_MESSAGE_BYTES / 4];
 	u32 hash[MD5_DIGEST_WORDS];
 	u32 i;
+	const struct in6_addr *daddr6 = (struct in6_addr *) daddr;
 
 	memcpy(hash, saddr, 16);
 	for (i = 0; i < 4; i++)
-		secret[i] = net_secret[i] + (__force u32) daddr[i];
+		secret[i] = net_secret[i] + (__force u32) daddr6->s6_addr32[i];
 	secret[4] = net_secret[4] + (__force u32)dport;
 	for (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)
 		secret[i] = net_secret[i];
@@ -165,10 +167,11 @@ u64 secure_dccpv6_sequence_number(__be32
 	u32 hash[MD5_DIGEST_WORDS];
 	u64 seq;
 	u32 i;
+	const struct in6_addr *daddr6 = (struct in6_addr *) daddr;
 
 	memcpy(hash, saddr, 16);
 	for (i = 0; i < 4; i++)
-		secret[i] = net_secret[i] + daddr[i];
+		secret[i] = net_secret[i] +  daddr6->s6_addr32[i];
 	secret[4] = net_secret[4] +
 		(((__force u16)sport << 16) + (__force u16)dport);
 	for (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -144,7 +144,7 @@ static __inline__ __be32 addr_bit_set(co
 	 * See include/asm-generic/bitops/le.h.
 	 */
 	return (__force __be32)(1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)) &
-	       addr[fn_bit >> 5];
+	       net_hdr_word(&addr[fn_bit >> 5]);
 }
 
 static __inline__ struct fib6_node * node_alloc(void)
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@ -452,7 +452,7 @@ static void tcp_sack(const struct sk_buf
 
 	/* Fast path for timestamp-only option */
 	if (length == TCPOLEN_TSTAMP_ALIGNED
-	    && *(__be32 *)ptr == htonl((TCPOPT_NOP << 24)
+	    && net_hdr_word(ptr) == htonl((TCPOPT_NOP << 24)
 				       | (TCPOPT_NOP << 16)
 				       | (TCPOPT_TIMESTAMP << 8)
 				       | TCPOLEN_TIMESTAMP))
--- a/net/netfilter/xt_LOG.c
+++ b/net/netfilter/xt_LOG.c
@@ -521,9 +521,9 @@ static void dump_ipv6_packet(struct sbuf
 	/* Max length: 44 "LEN=65535 TC=255 HOPLIMIT=255 FLOWLBL=FFFFF " */
 	sb_add(m, "LEN=%Zu TC=%u HOPLIMIT=%u FLOWLBL=%u ",
 	       ntohs(ih->payload_len) + sizeof(struct ipv6hdr),
-	       (ntohl(*(__be32 *)ih) & 0x0ff00000) >> 20,
+	       (ntohl(net_hdr_word(ih)) & 0x0ff00000) >> 20,
 	       ih->hop_limit,
-	       (ntohl(*(__be32 *)ih) & 0x000fffff));
+	       (ntohl(net_hdr_word(ih)) & 0x000fffff));
 
 	fragment = 0;
 	ptr = ip6hoff + sizeof(struct ipv6hdr);
--- a/net/xfrm/xfrm_input.c
+++ b/net/xfrm/xfrm_input.c
@@ -77,8 +77,8 @@ int xfrm_parse_spi(struct sk_buff *skb,
 	if (!pskb_may_pull(skb, hlen))
 		return -EINVAL;
 
-	*spi = *(__be32*)(skb_transport_header(skb) + offset);
-	*seq = *(__be32*)(skb_transport_header(skb) + offset_seq);
+	*spi = net_hdr_word(skb_transport_header(skb) + offset);
+	*seq = net_hdr_word(skb_transport_header(skb) + offset_seq);
 	return 0;
 }
 
